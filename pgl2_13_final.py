####################################################################################
####################################################################################
###
### Python code accompanying the paper
###    'PGL(2,13) is a maximal subgroup of the Monster'
### by Dietrich, Lee, Popiel (2023)
###
### Code relies in Python package mmgroup by Martin Seysen
### https://github.com/Martin-Seysen/mmgroup
###
###
### Main results are the following:
###  * Standard generators for G = 2^(1+24).Co1, see SECTION 1
###  * Generators for new maximal PGL(2,13), see SECTION 2
###  * Computations assisting the proofs in the paper, see SECTION 3
###
####################################################################################
####################################################################################


from mmgroup import *
import random
import itertools as it
import numpy as np
from functools import reduce


####################################################################################
####################################################################################
####################################################################################
### SECTION 1
###
### standard generators for G = 2^(1+24).Co1
###
### call verify_std_gens_G(a,b) to verify correctness
###
a = MM("M<y_2feh*x_51h*d_6f2h*p_199553794*l_2*p_1900800*l_2*p_684120>")
b = MM("M<y_32bh*x_0e4h*d_30fh*p_81928987*l_2*p_2880*l_1*p_21312*l_1*p_10455360>")
###
####################################################################################


####################################################################################
### verify that a and b generated G
###

### define group commutator [a,b] = a^{-1} * b^{-1} * a * b
def Comm(a,b):
    return a**(-1)*b**(-1)*a*b


### various check to confirm that a and b have the claimed properties
def verify_std_gens_G(a,b):
    #check central element
    cent = MM("M<x_1000h>")
    if not (Comm(a**2,b**3) == cent and a*cent == cent*a and b*cent == cent*b):
        return False
    #check membership in G_x0
    c0 = a.in_G_x0() and b.in_G_x0()
    #check right orders
    c1 = a.order()==4 and b.order()==6
    #check belong to right classes of G_x0
    c2 = a.chi_G_x0()[1]==-13 and b.chi_G_x0()[1]==2 and (b.chi_G_x0()[0]==-3 or b.chi_G_x0()[0]==5)
    #check product in right class
    c3 = (a*b).order()==40 and ((a*b)**-1).chi_G_x0()[1]==0 and ((a*b)**-1).chi_G_x0()[2]*((a*b)**-1).chi_G_x0()[3]==0
    #check that elt powers are not central in subgroup generated by a and b
    c4 = (a**2)*b != b*(a**2) and (b**2)*a != a*(b**2) and (b**3)*a != a*(b**3)
    #check that a*b*a*(b^2) has order 6 in quotient - choices are 6 or 21 so if latter, evaluates to false
    c5 = (a*b*a*b**2).order() % 6 ==0
    if not (c0 and c1 and c2 and c3 and c4 and c5):
        return False
    #now check that we can generate Q: construct j0,..,j23
    myels = [(a**2)**((a*b)**i) for i in range(0,24)]
    #elts need to lie in Q, commute modulo cent, and should have order 2
    for i in range(0,24):
        if not myels[i].in_Q_x0():
            return False
        for j in range(i+1,24):
            if (myels[i]*myels[j] != myels[j]*myels[i]) and Comm(myels[i],myels[j]) != cent:
                return False
            if myels[i].order() != 2:
                return False
    print("all good so far; now check size of Q;")
    print("this will take a long time")
    #check that ((myels[0]**i0)* ... *(myels[23]**i23)).order() == 1 mod <cent> only for i0==...==i23=0
    s=0
    tups = it.product([0,1], repeat=24)
    for t in tups:
        if np.sum(t)==0:
            continue
        if s % 10000 == 0:
            print("Done ", s, " of ",2**24," tuples: ",100*s/2**24,"%", end='\r')
        terms = [myels[i]**t[i] for i in range(24)]
        prod = reduce((lambda x, y: x * y), terms)
        if prod.order() ==1 or (prod*cent).order()==1:
            print("Found identity with tuple: ", t)
            return False
        s+=1
    print("all tests ok")
    return True


### verify_std_gens_G(a,b) returns true

####################################################################################

### the homomorphism G --> GL_2(24) whose image is a 24-dim Z_2 rep of Co1
def elt_to_24_mat(g):
    mat = []
    for i in range(24):
        x = generators.gen_leech2_op_word_leech2(2**(23-i),g.mmdata,len(g.mmdata),0)
        mat.append([int(d) for d in format( (x %2**24), '#026b')[2:]])
    return mat

####################################################################################

### MAGMA: The following Magma code confirms that <A,B> generate Co1;
### below A and B are the two matrices in GL(24,2) that have been computed 
### via elt_to_24_mat(a) and elt_to_24_mat(b)
###
###   A := GL(24, GF(2)) ! Matrix(GF(2), 24, 24, \[ 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
###   0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1,
###   0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
###   0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0,
###   0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0,
###   1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0,
###   0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1,
###   0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1,
###   1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1,
###   0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0,
###   0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0,
###   0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1,
###   0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1,
###   1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0
###   ]);
###   B := GL(24, GF(2)) ! Matrix(GF(2), 24, 24, \[ 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1,
###   1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1,
###   1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1,
###   0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1,
###   1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1,
###   1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0,
###   0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0,
###   0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1,
###   0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1,
###   0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1,
###   0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1,
###   1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1,
###   0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1,
###   0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1
###   ]);
###
###   G := sub<GL(24,2)|[A,B]>;
###   LMGCompositionFactors(G);
###   // Output: G -- Co1 -- 1
###
####################################################################################
###
### In conclusion:
### The latter proves that the images of {a,b} in GL(24,2) generate Co1.
### Above we have also seen that we can use {a,b} to generate Q
### All elements lie in G, so it follows that G = <a,b>







####################################################################################
####################################################################################
####################################################################################
### SECTION 2
### Generators of L = PGL(2,13) = <g13, g6, i2, a12>,
### where g13, g6, i2, a12 have orders 13, 6, 2, 12.
###
### We have PSL(2,13) = <g13, g6, i2> with <g13,g6> = 13:6 and <g6,i2> = D12
###
g13 = MM("M<y_519h*x_0cb8h*d_3abh*p_178084032*l_2*p_2344320*l_2*p_471482*l_1*t_1*l_2*p_2830080*l_2*p_22371347*l_2*t_2*l_1*p_1499520*l_2*p_22779365*l_2*t_1*l_2*p_2597760*l_1*p_11179396*t_1*l_1*p_1499520*l_2*p_85838017*t_2*l_1*p_1499520*l_1*p_64024721*t_2*l_2*p_2386560*l_2*p_21335269>")

g6 = MM("M<y_764h*x_590h*d_0bf6h*p_63465756*l_1*p_24000*l_2*p_528432*t_1*l_2*p_1457280*l_1*p_23214136*l_1*t_2*l_2*p_2344320*l_2*p_13038217*l_2*t_1*l_2*p_2956800*l_1*p_85332887*t_2*l_2*p_2830080*l_2*p_85335745*t_2*l_2*p_1900800*l_2*p_13472*t_2*l_2*p_2386560*l_2*p_85413728*t_1*l_2*p_2386560*l_2*p_53803593>")

i2 = MM("M<y_6ch*x_7ch*d_52ah*p_115885662*l_2*p_2787840*l_2*p_12552610*l_2*t_1*l_2*p_1900800*l_2*p_31998118*l_2*t_2*l_2*p_80762880*l_1*p_243091248*l_2*t_1*l_2*p_2597760*l_1*p_42794439*t_1*l_1*p_1394880*l_2*p_64015152*t_1*l_1*p_2027520*l_1*p_177984*t_1*l_2*p_79432320*l_1*p_161927136>")

a12 = MM("M<y_1afh*x_1661h*d_2ddh*p_208095583*l_2*p_1943040*l_2*p_1974295*l_2*t_2*l_2*p_1900800*l_2*p_10778*l_2*t_2*l_2*p_1900800*l_2*p_1868387*l_1*t_1*l_2*p_2956800*l_1*p_11159238*t_1*l_2*p_1985280*l_1*p_86275805*t_2*l_2*p_2386560*l_2*p_42712609*t_2*l_1*p_1499520*l_1*p_106699812>")
####################################################################################
####################################################################################


####################################################################################
###
### verify that g13, g6, i2, a12  generated PGL(2,13)
### use presentation of PGL(2,13) provided by Corollary 4 in 
###    Robertson and Williams
###    'A presentation of PGL(2,p) with three defining relations'
###    Proc. Edinb. Math. Soc. 27 (145-149 1994)
###
### various check to confirm that a and b have the claimed properties
def verify_gens_PGL2_13(g13,g6,i2,a12):
   u = (i2*g6**4)*a12
   v = g13
   rels = [u**2,v**13,(u*(v**2))**4,(u*v*u*(v**2))**3]
   for i in rels:
      if not i.order() == 1:
         return False
   if not (g13.order() == 13 and g6.order() == 6 and i2.order() == 2 and a12.order() == 12):
         return False
   return True


## verify_gens_PGL2_13(g13,g6,i2,a12) returns true

####################################################################################
####################################################################################
####################################################################################
### SECTION 3
###
### Computation used in the proof of Corollary 3.3:
### We have g6=y*t and need to show that the only element in <t> fixed by i2 is t^0
###
y = MM("M<y_4fh*x_1331h*d_0d46h*p_79853974*l_2*p_1943040*l_2*p_2398522*t_1*l_2*p_2344320*l_2*p_1858757*l_2*t_1*l_1*p_960*l_2*p_3120*l_2*p_517440*t_2*l_2*p_2597760*l_1*p_12132032*t_2*l_2*p_2880*l_1*p_465840*l_1*p_1565760*t_1*l_2*p_960*l_1*p_63994992*t_1*l_1*p_2027520*l_1*p_50146>")
t = MM("M<y_44eh*x_1906h*d_2d9h*p_173881751*l_1*p_2640000*l_1*p_1925314*l_1*t_1*l_1*p_2999040*l_1*p_2392772*l_1*t_1*l_1*p_1499520*l_1*p_32461673*l_1*t_1*l_2*p_2344320*l_2*p_84794*t_2*l_2*p_2956800*l_1*p_85413707*t_2*l_2*p_1985280*l_1*p_96477721*t_1*l_2*p_1985280*l_1*p_64023741>")

###Verify that g6 = y*t, and that the only elt of <t> that is fixed by i2 is the identity
def verify_cent_PGL2_13(g6,y,t,i2):
   return g6==y*t and [t**i for i in range(6) if (t**i)**i2==t**i] == [MM("M<1>")]
